package help.me.orm.entity;
// Generated Nov 26, 2015 6:04:16 PM by Hibernate Tools 4.3.1.Final

import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.OrderBy;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.UniqueConstraint;

import org.apache.commons.validator.EmailValidator;
import org.apache.commons.validator.ValidatorException;
import org.hibernate.annotations.Generated;
import org.hibernate.annotations.GenerationTime;

/**
 * User generated by hbm2java
 */
/**
 * @author triviski
 *
 */
@SuppressWarnings("serial")
@Entity
@Table(name = "user", uniqueConstraints = @UniqueConstraint(columnNames = "email") )
public class User implements java.io.Serializable {

	private int userId;
	private Info info;
	private Settings settings;
	private String email;
    private Set<Location> locations = new HashSet<Location>(0);
    private Set<License> licenses = new HashSet<License>(0);

	
	private Date createdAt;
	private Date updatedAt;

	/**
	 * 
	 */
	public User() {
	}

	/**
	 * @param userId
	 * @param info
	 * @param settings
	 * @param email
	 * @throws ValidatorException
	 */
	public User(int userId, Info info, Settings settings, String email) throws ValidatorException {
		this.userId = userId;
		this.info = info;
		this.settings = settings;
		
		this.setEmail(email);

	}

	/**
	 * @param userId
	 * @param info
	 * @param settings
	 * @param email
	 * @param createdAt
	 * @param updatedAt
	 * @throws ValidatorException
	 */
	public User(int userId, Info info, Settings settings, String email, Date createdAt, Date updatedAt) throws ValidatorException {
		this.userId = userId;
		this.info = info;
		this.settings = settings;
		this.createdAt = createdAt;
		this.updatedAt = updatedAt;
		
		this.setEmail(email);
	}

    @Id 
    @GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name = "userId", unique = true, nullable = false)
	public int getUserId() {
		return this.userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	@JoinColumn(name = "info", nullable=true)
	@OneToOne(fetch=FetchType.LAZY, cascade=CascadeType.ALL)
	public Info getInfo() {
		return this.info;
	}

	public void setInfo(Info info) {
		this.info = info;
	}

	@JoinColumn(name = "settings", nullable=true)
	@OneToOne(fetch=FetchType.LAZY, cascade=CascadeType.ALL)
	public Settings getSettings() {
		return this.settings;
	}

	public void setSettings(Settings settings) {
		this.settings = settings;
	}

	@Column(name = "email", unique = true, nullable = false, length = 50)
	public String getEmail() {
		return this.email;
	}

	/**
	 * @param email
	 */
	public void setEmail(String email) {
		if (!EmailValidator.getInstance().isValid(email)) {
			throw new IllegalStateException("Email address is invalid.");
		}
		
		this.email = email;
	}

    @OneToMany(mappedBy="user", fetch=FetchType.LAZY)
    @OrderBy("created_at")
    public Set<Location> getLocations() {
        return this.locations;
    }
    
    public void setLocations(Set<Location> locations) {
        this.locations = locations;
    }

    @JoinColumn(name = "licenseId")
    @OneToMany(fetch=FetchType.LAZY, cascade=CascadeType.ALL)
    public Set<License> getLicenses() {
        return this.licenses;
    }
    
    public void setLicenses(Set<License> licenses) {
        this.licenses = licenses;
    }
	
	@Generated(GenerationTime.INSERT) 
	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "created_at", length = 19, insertable=true, updatable=false)
	public Date getCreatedAt() {
		return this.createdAt;
	}

	public void setCreatedAt(Date createdAt) {
		this.createdAt = createdAt;
	}

	@Generated(GenerationTime.ALWAYS) 
	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "updated_at", length = 19, insertable=true, updatable=true)
	public Date getUpdatedAt() {
		return this.updatedAt;
	}

	public void setUpdatedAt(Date updatedAt) {
		this.updatedAt = updatedAt;
	}
	
	@PreUpdate
	@PrePersist
	public void updateTimeStamps() {
		this.updatedAt = new Date();
		
		if (this.createdAt == null) {
			this.createdAt = this.updatedAt;
		}
	}

	@Override
	public String toString() {
		final int maxLen = 10;
		StringBuilder builder = new StringBuilder();
		builder.append("User [userId=");
		builder.append(userId);
		builder.append(", info=");
		builder.append(info);
		builder.append(", settings=");
		builder.append(settings);
		builder.append(", email=");
		builder.append(email);
		builder.append(", locations=");
		builder.append(locations != null ? toString(locations, maxLen) : null);
		builder.append(", licenses=");
		builder.append(licenses != null ? toString(licenses, maxLen) : null);
		builder.append(", createdAt=");
		builder.append(createdAt);
		builder.append(", updatedAt=");
		builder.append(updatedAt);
		builder.append("]");
		return builder.toString();
	}

	private String toString(Collection<?> collection, int maxLen) {
		StringBuilder builder = new StringBuilder();
		builder.append("[");
		int i = 0;
		for (Iterator<?> iterator = collection.iterator(); iterator.hasNext() && i < maxLen; i++) {
			if (i > 0)
				builder.append(", ");
			builder.append(iterator.next());
		}
		builder.append("]");
		return builder.toString();
	}

}
