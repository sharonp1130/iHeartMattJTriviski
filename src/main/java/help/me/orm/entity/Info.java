package help.me.orm.entity;
// Generated Nov 26, 2015 6:04:16 PM by Hibernate Tools 4.3.1.Final

import java.util.Date;
import java.util.regex.Pattern;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

import org.hibernate.annotations.Generated;
import org.hibernate.annotations.GenerationTime;

/**
 * Info generated by hbm2java
 */
@SuppressWarnings("serial")
@Entity
@Table(name = "info")
public class Info implements java.io.Serializable {
	private static final Pattern PHONE_PATTERN = 
			Pattern.compile("\\(\\d{3}\\) \\d{3}-\\d{4}");
	private static final Pattern CITY_NOT_MATCH_PATTERN = 
			Pattern.compile(".+\\d.+");
	private static final Pattern ZIP_PATTERN = 
			Pattern.compile("^\\d{5}(-\\d{4})*?$");

	
	private Integer infoId;
	private User user;
	private String address;
	private String city;
	private String zipcode;
	private String phoneNumber;
	private boolean phoneOk;
	private boolean textOk;
	private boolean emailOk;
	private Date createdAt;
	private Date updatedAt;

	public Info() {
	}

	/**
	 * @param infoId
	 * @param user
	 * @param address
	 * @param city
	 * @param zipcode
	 * @param phoneNumber
	 * @param phoneOk
	 * @param textOk
	 * @param emailOk
	 * @throws Exception - Telephone, city or zipcode is invalid.
	 */
	public Info(int infoId, User user, String address, String city, String zipcode, String phoneNumber, boolean phoneOk,
			boolean textOk, boolean emailOk) throws Exception {
		this.infoId = infoId;
		this.user = user;
		this.address = address;
		this.phoneOk = phoneOk;
		this.textOk = textOk;
		this.emailOk = emailOk;
		
		this.setCity(city);
		this.setZipcode(zipcode);
		this.setPhoneNumber(phoneNumber);
	}

	/**
	 * @param infoId
	 * @param user
	 * @param address
	 * @param city
	 * @param zipcode
	 * @param phoneNumber
	 * @param phoneOk
	 * @param textOk
	 * @param emailOk
	 * @param createdAt
	 * @param updatedAt
	 * @throws Exception - Telephone number format is invalid.
	 */
	public Info(int infoId, User user, String address, String city, String zipcode, String phoneNumber, boolean phoneOk,
			boolean textOk, boolean emailOk, Date createdAt, Date updatedAt) throws Exception {
		this.infoId = infoId;
		this.user = user;
		this.address = address;
		this.phoneOk = phoneOk;
		this.textOk = textOk;
		this.emailOk = emailOk;
		this.createdAt = createdAt;
		this.updatedAt = updatedAt;
		
		this.setCity(city);
		this.setZipcode(zipcode);
		this.setPhoneNumber(phoneNumber);
	}

    @Id 
    @GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name = "infoId", unique = true, nullable = false)
	public Integer getInfoId() {
		return this.infoId;
	}

	public void setInfoId(int infoId) {
		this.infoId = infoId;
	}

	@JoinColumn(name="user", nullable=true)
	@OneToOne(fetch=FetchType.LAZY)
	public User getUser() {
		return this.user;
	}

	public void setUser(User user) {
		this.user = user;
	}

	@Column(name = "address", nullable = false, length = 64)
	public String getAddress() {
		return this.address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	@Column(name = "city", nullable = false, length = 64)
	public String getCity() {
		return this.city;
	}

	/**
	 * Verifies the city does not have any numbers in it.  Not sure if there is any other validation we can do.
	 * 
	 * @param city
	 * @throws Exception
	 */
	public void setCity(String city) {
		if (CITY_NOT_MATCH_PATTERN.matcher(city).matches()) {
			throw new IllegalStateException(String.format("City '%s' should not contain any numbers: %s", city, CITY_NOT_MATCH_PATTERN));
		}
		this.city = city;
	}

	@Column(name = "zipcode", nullable = false, length = 5)
	public String getZipcode() {
		return this.zipcode;
	}

	/**
	 * Verifies the zip code.
	 * @param zipcode
	 * @throws Exception
	 */
	public void setZipcode(String zipcode) {
		if (!ZIP_PATTERN.matcher(zipcode).matches()) {
			throw new IllegalStateException(String.format("Zip code '%s' does not match the expected format: %s", zipcode, ZIP_PATTERN));
		}
		this.zipcode = zipcode;
	}

	@Column(name = "phoneNumber", nullable = false, length = 20)
	public String getPhoneNumber() {
		return this.phoneNumber;
	}

	/**
	 * Verifies the phone number format before setting it.
	 * 
	 * @param phoneNumber
	 * @throws Exception
	 */
	public void setPhoneNumber(String phoneNumber) {
		if (!PHONE_PATTERN.matcher(phoneNumber).matches()) {
			throw new IllegalStateException(String.format("Telephone number '%s' does not match the expected format: %s", phoneNumber, PHONE_PATTERN));
		}
		this.phoneNumber = phoneNumber;
	}

	@Column(name = "phoneOk", nullable = false)
	public boolean isPhoneOk() {
		return this.phoneOk;
	}

	public void setPhoneOk(boolean phoneOk) {
		this.phoneOk = phoneOk;
	}

	@Column(name = "textOk", nullable = false)
	public boolean isTextOk() {
		return this.textOk;
	}

	public void setTextOk(boolean textOk) {
		this.textOk = textOk;
	}

	@Column(name = "emailOk", nullable = false)
	public boolean isEmailOk() {
		return this.emailOk;
	}

	public void setEmailOk(boolean emailOk) {
		this.emailOk = emailOk;
	}

	@Generated(GenerationTime.INSERT) 
	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "created_at", length = 19, insertable=false, updatable=false)
	public Date getCreatedAt() {
		return this.createdAt;
	}

	public void setCreatedAt(Date createdAt) {
		this.createdAt = createdAt;
	}

	@Generated(GenerationTime.ALWAYS) 
	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "updated_at", length = 19, insertable=false, updatable=true)
	public Date getUpdatedAt() {
		return this.updatedAt;
	}

	public void setUpdatedAt(Date updatedAt) {
		this.updatedAt = updatedAt;
	}


}
